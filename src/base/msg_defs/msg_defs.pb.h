// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_defs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fdefs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fdefs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_5fdefs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_5fdefs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_5fdefs_2eproto;
namespace logpb {
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Force;
struct ForceDefaultTypeInternal;
extern ForceDefaultTypeInternal _Force_default_instance_;
class Force_Speed;
struct Force_SpeedDefaultTypeInternal;
extern Force_SpeedDefaultTypeInternal _Force_Speed_default_instance_;
class Pressure;
struct PressureDefaultTypeInternal;
extern PressureDefaultTypeInternal _Pressure_default_instance_;
}  // namespace logpb
PROTOBUF_NAMESPACE_OPEN
template<> ::logpb::Data* Arena::CreateMaybeMessage<::logpb::Data>(Arena*);
template<> ::logpb::Force* Arena::CreateMaybeMessage<::logpb::Force>(Arena*);
template<> ::logpb::Force_Speed* Arena::CreateMaybeMessage<::logpb::Force_Speed>(Arena*);
template<> ::logpb::Pressure* Arena::CreateMaybeMessage<::logpb::Pressure>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace logpb {

enum Force_Speed_Type : int {
  Force_Speed_Type_I2C = 1,
  Force_Speed_Type_SPI = 2
};
bool Force_Speed_Type_IsValid(int value);
constexpr Force_Speed_Type Force_Speed_Type_Type_MIN = Force_Speed_Type_I2C;
constexpr Force_Speed_Type Force_Speed_Type_Type_MAX = Force_Speed_Type_SPI;
constexpr int Force_Speed_Type_Type_ARRAYSIZE = Force_Speed_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Force_Speed_Type_descriptor();
template<typename T>
inline const std::string& Force_Speed_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Force_Speed_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Force_Speed_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Force_Speed_Type_descriptor(), enum_t_value);
}
inline bool Force_Speed_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Force_Speed_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Force_Speed_Type>(
    Force_Speed_Type_descriptor(), name, value);
}
enum Message_Types : int {
  Pressure_Type = 1,
  Force_Type = 2,
  Data_Type = 3
};
bool Message_Types_IsValid(int value);
constexpr Message_Types Message_Types_MIN = Pressure_Type;
constexpr Message_Types Message_Types_MAX = Data_Type;
constexpr int Message_Types_ARRAYSIZE = Message_Types_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_Types_descriptor();
template<typename T>
inline const std::string& Message_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_Types_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_Types_descriptor(), enum_t_value);
}
inline bool Message_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_Types* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_Types>(
    Message_Types_descriptor(), name, value);
}
// ===================================================================

class Pressure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logpb.Pressure) */ {
 public:
  inline Pressure() : Pressure(nullptr) {}
  ~Pressure() override;
  explicit PROTOBUF_CONSTEXPR Pressure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pressure(const Pressure& from);
  Pressure(Pressure&& from) noexcept
    : Pressure() {
    *this = ::std::move(from);
  }

  inline Pressure& operator=(const Pressure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pressure& operator=(Pressure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pressure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pressure* internal_default_instance() {
    return reinterpret_cast<const Pressure*>(
               &_Pressure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Pressure& a, Pressure& b) {
    a.Swap(&b);
  }
  inline void Swap(Pressure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pressure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pressure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pressure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pressure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pressure& from) {
    Pressure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pressure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logpb.Pressure";
  }
  protected:
  explicit Pressure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressureFieldNumber = 2,
    kTemperatureFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional sfixed32 pressure = 2;
  bool has_pressure() const;
  private:
  bool _internal_has_pressure() const;
  public:
  void clear_pressure();
  int32_t pressure() const;
  void set_pressure(int32_t value);
  private:
  int32_t _internal_pressure() const;
  void _internal_set_pressure(int32_t value);
  public:

  // optional sfixed32 temperature = 3;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // optional .logpb.Message_Types type = 1 [default = Pressure_Type];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::logpb::Message_Types type() const;
  void set_type(::logpb::Message_Types value);
  private:
  ::logpb::Message_Types _internal_type() const;
  void _internal_set_type(::logpb::Message_Types value);
  public:

  // @@protoc_insertion_point(class_scope:logpb.Pressure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t pressure_;
    int32_t temperature_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fdefs_2eproto;
};
// -------------------------------------------------------------------

class Force_Speed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logpb.Force.Speed) */ {
 public:
  inline Force_Speed() : Force_Speed(nullptr) {}
  ~Force_Speed() override;
  explicit PROTOBUF_CONSTEXPR Force_Speed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Force_Speed(const Force_Speed& from);
  Force_Speed(Force_Speed&& from) noexcept
    : Force_Speed() {
    *this = ::std::move(from);
  }

  inline Force_Speed& operator=(const Force_Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Force_Speed& operator=(Force_Speed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Force_Speed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Force_Speed* internal_default_instance() {
    return reinterpret_cast<const Force_Speed*>(
               &_Force_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Force_Speed& a, Force_Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Force_Speed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Force_Speed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Force_Speed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Force_Speed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Force_Speed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Force_Speed& from) {
    Force_Speed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force_Speed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logpb.Force.Speed";
  }
  protected:
  explicit Force_Speed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Force_Speed_Type Type;
  static constexpr Type I2C =
    Force_Speed_Type_I2C;
  static constexpr Type SPI =
    Force_Speed_Type_SPI;
  static inline bool Type_IsValid(int value) {
    return Force_Speed_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Force_Speed_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Force_Speed_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Force_Speed_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Force_Speed_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Force_Speed_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Force_Speed_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 2,
    kTFieldNumber = 1,
  };
  // optional sfixed32 val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  int32_t val() const;
  void set_val(int32_t value);
  private:
  int32_t _internal_val() const;
  void _internal_set_val(int32_t value);
  public:

  // required .logpb.Force.Speed.Type t = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  ::logpb::Force_Speed_Type t() const;
  void set_t(::logpb::Force_Speed_Type value);
  private:
  ::logpb::Force_Speed_Type _internal_t() const;
  void _internal_set_t(::logpb::Force_Speed_Type value);
  public:

  // @@protoc_insertion_point(class_scope:logpb.Force.Speed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t val_;
    int t_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fdefs_2eproto;
};
// -------------------------------------------------------------------

class Force final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logpb.Force) */ {
 public:
  inline Force() : Force(nullptr) {}
  ~Force() override;
  explicit PROTOBUF_CONSTEXPR Force(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Force(const Force& from);
  Force(Force&& from) noexcept
    : Force() {
    *this = ::std::move(from);
  }

  inline Force& operator=(const Force& from) {
    CopyFrom(from);
    return *this;
  }
  inline Force& operator=(Force&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Force& default_instance() {
    return *internal_default_instance();
  }
  static inline const Force* internal_default_instance() {
    return reinterpret_cast<const Force*>(
               &_Force_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Force& a, Force& b) {
    a.Swap(&b);
  }
  inline void Swap(Force* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Force* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Force* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Force>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Force& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Force& from) {
    Force::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logpb.Force";
  }
  protected:
  explicit Force(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Force_Speed Speed;

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureFieldNumber = 3,
    kSFieldNumber = 4,
    kForceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated sfixed32 temperature = 3;
  int temperature_size() const;
  private:
  int _internal_temperature_size() const;
  public:
  void clear_temperature();
  private:
  int32_t _internal_temperature(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_temperature() const;
  void _internal_add_temperature(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_temperature();
  public:
  int32_t temperature(int index) const;
  void set_temperature(int index, int32_t value);
  void add_temperature(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      temperature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_temperature();

  // repeated .logpb.Force.Speed s = 4;
  int s_size() const;
  private:
  int _internal_s_size() const;
  public:
  void clear_s();
  ::logpb::Force_Speed* mutable_s(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force_Speed >*
      mutable_s();
  private:
  const ::logpb::Force_Speed& _internal_s(int index) const;
  ::logpb::Force_Speed* _internal_add_s();
  public:
  const ::logpb::Force_Speed& s(int index) const;
  ::logpb::Force_Speed* add_s();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force_Speed >&
      s() const;

  // optional sfixed32 force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  int32_t force() const;
  void set_force(int32_t value);
  private:
  int32_t _internal_force() const;
  void _internal_set_force(int32_t value);
  public:

  // optional .logpb.Message_Types type = 1 [default = Force_Type];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::logpb::Message_Types type() const;
  void set_type(::logpb::Message_Types value);
  private:
  ::logpb::Message_Types _internal_type() const;
  void _internal_set_type(::logpb::Message_Types value);
  public:

  // @@protoc_insertion_point(class_scope:logpb.Force)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > temperature_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force_Speed > s_;
    int32_t force_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fdefs_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logpb.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logpb.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressureFieldNumber = 2,
    kForceFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated .logpb.Pressure pressure = 2;
  int pressure_size() const;
  private:
  int _internal_pressure_size() const;
  public:
  void clear_pressure();
  ::logpb::Pressure* mutable_pressure(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Pressure >*
      mutable_pressure();
  private:
  const ::logpb::Pressure& _internal_pressure(int index) const;
  ::logpb::Pressure* _internal_add_pressure();
  public:
  const ::logpb::Pressure& pressure(int index) const;
  ::logpb::Pressure* add_pressure();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Pressure >&
      pressure() const;

  // repeated .logpb.Force force = 3;
  int force_size() const;
  private:
  int _internal_force_size() const;
  public:
  void clear_force();
  ::logpb::Force* mutable_force(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force >*
      mutable_force();
  private:
  const ::logpb::Force& _internal_force(int index) const;
  ::logpb::Force* _internal_add_force();
  public:
  const ::logpb::Force& force(int index) const;
  ::logpb::Force* add_force();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force >&
      force() const;

  // optional .logpb.Message_Types type = 1 [default = Data_Type];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::logpb::Message_Types type() const;
  void set_type(::logpb::Message_Types value);
  private:
  ::logpb::Message_Types _internal_type() const;
  void _internal_set_type(::logpb::Message_Types value);
  public:

  // @@protoc_insertion_point(class_scope:logpb.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Pressure > pressure_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force > force_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fdefs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pressure

// optional .logpb.Message_Types type = 1 [default = Pressure_Type];
inline bool Pressure::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Pressure::has_type() const {
  return _internal_has_type();
}
inline void Pressure::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::logpb::Message_Types Pressure::_internal_type() const {
  return static_cast< ::logpb::Message_Types >(_impl_.type_);
}
inline ::logpb::Message_Types Pressure::type() const {
  // @@protoc_insertion_point(field_get:logpb.Pressure.type)
  return _internal_type();
}
inline void Pressure::_internal_set_type(::logpb::Message_Types value) {
  assert(::logpb::Message_Types_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void Pressure::set_type(::logpb::Message_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:logpb.Pressure.type)
}

// optional sfixed32 pressure = 2;
inline bool Pressure::_internal_has_pressure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Pressure::has_pressure() const {
  return _internal_has_pressure();
}
inline void Pressure::clear_pressure() {
  _impl_.pressure_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Pressure::_internal_pressure() const {
  return _impl_.pressure_;
}
inline int32_t Pressure::pressure() const {
  // @@protoc_insertion_point(field_get:logpb.Pressure.pressure)
  return _internal_pressure();
}
inline void Pressure::_internal_set_pressure(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pressure_ = value;
}
inline void Pressure::set_pressure(int32_t value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:logpb.Pressure.pressure)
}

// optional sfixed32 temperature = 3;
inline bool Pressure::_internal_has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Pressure::has_temperature() const {
  return _internal_has_temperature();
}
inline void Pressure::clear_temperature() {
  _impl_.temperature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Pressure::_internal_temperature() const {
  return _impl_.temperature_;
}
inline int32_t Pressure::temperature() const {
  // @@protoc_insertion_point(field_get:logpb.Pressure.temperature)
  return _internal_temperature();
}
inline void Pressure::_internal_set_temperature(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.temperature_ = value;
}
inline void Pressure::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:logpb.Pressure.temperature)
}

// -------------------------------------------------------------------

// Force_Speed

// required .logpb.Force.Speed.Type t = 1;
inline bool Force_Speed::_internal_has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Force_Speed::has_t() const {
  return _internal_has_t();
}
inline void Force_Speed::clear_t() {
  _impl_.t_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::logpb::Force_Speed_Type Force_Speed::_internal_t() const {
  return static_cast< ::logpb::Force_Speed_Type >(_impl_.t_);
}
inline ::logpb::Force_Speed_Type Force_Speed::t() const {
  // @@protoc_insertion_point(field_get:logpb.Force.Speed.t)
  return _internal_t();
}
inline void Force_Speed::_internal_set_t(::logpb::Force_Speed_Type value) {
  assert(::logpb::Force_Speed_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.t_ = value;
}
inline void Force_Speed::set_t(::logpb::Force_Speed_Type value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:logpb.Force.Speed.t)
}

// optional sfixed32 val = 2;
inline bool Force_Speed::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Force_Speed::has_val() const {
  return _internal_has_val();
}
inline void Force_Speed::clear_val() {
  _impl_.val_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Force_Speed::_internal_val() const {
  return _impl_.val_;
}
inline int32_t Force_Speed::val() const {
  // @@protoc_insertion_point(field_get:logpb.Force.Speed.val)
  return _internal_val();
}
inline void Force_Speed::_internal_set_val(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.val_ = value;
}
inline void Force_Speed::set_val(int32_t value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:logpb.Force.Speed.val)
}

// -------------------------------------------------------------------

// Force

// optional .logpb.Message_Types type = 1 [default = Force_Type];
inline bool Force::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Force::has_type() const {
  return _internal_has_type();
}
inline void Force::clear_type() {
  _impl_.type_ = 2;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::logpb::Message_Types Force::_internal_type() const {
  return static_cast< ::logpb::Message_Types >(_impl_.type_);
}
inline ::logpb::Message_Types Force::type() const {
  // @@protoc_insertion_point(field_get:logpb.Force.type)
  return _internal_type();
}
inline void Force::_internal_set_type(::logpb::Message_Types value) {
  assert(::logpb::Message_Types_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void Force::set_type(::logpb::Message_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:logpb.Force.type)
}

// optional sfixed32 force = 2;
inline bool Force::_internal_has_force() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Force::has_force() const {
  return _internal_has_force();
}
inline void Force::clear_force() {
  _impl_.force_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Force::_internal_force() const {
  return _impl_.force_;
}
inline int32_t Force::force() const {
  // @@protoc_insertion_point(field_get:logpb.Force.force)
  return _internal_force();
}
inline void Force::_internal_set_force(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.force_ = value;
}
inline void Force::set_force(int32_t value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:logpb.Force.force)
}

// repeated sfixed32 temperature = 3;
inline int Force::_internal_temperature_size() const {
  return _impl_.temperature_.size();
}
inline int Force::temperature_size() const {
  return _internal_temperature_size();
}
inline void Force::clear_temperature() {
  _impl_.temperature_.Clear();
}
inline int32_t Force::_internal_temperature(int index) const {
  return _impl_.temperature_.Get(index);
}
inline int32_t Force::temperature(int index) const {
  // @@protoc_insertion_point(field_get:logpb.Force.temperature)
  return _internal_temperature(index);
}
inline void Force::set_temperature(int index, int32_t value) {
  _impl_.temperature_.Set(index, value);
  // @@protoc_insertion_point(field_set:logpb.Force.temperature)
}
inline void Force::_internal_add_temperature(int32_t value) {
  _impl_.temperature_.Add(value);
}
inline void Force::add_temperature(int32_t value) {
  _internal_add_temperature(value);
  // @@protoc_insertion_point(field_add:logpb.Force.temperature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Force::_internal_temperature() const {
  return _impl_.temperature_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Force::temperature() const {
  // @@protoc_insertion_point(field_list:logpb.Force.temperature)
  return _internal_temperature();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Force::_internal_mutable_temperature() {
  return &_impl_.temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Force::mutable_temperature() {
  // @@protoc_insertion_point(field_mutable_list:logpb.Force.temperature)
  return _internal_mutable_temperature();
}

// repeated .logpb.Force.Speed s = 4;
inline int Force::_internal_s_size() const {
  return _impl_.s_.size();
}
inline int Force::s_size() const {
  return _internal_s_size();
}
inline void Force::clear_s() {
  _impl_.s_.Clear();
}
inline ::logpb::Force_Speed* Force::mutable_s(int index) {
  // @@protoc_insertion_point(field_mutable:logpb.Force.s)
  return _impl_.s_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force_Speed >*
Force::mutable_s() {
  // @@protoc_insertion_point(field_mutable_list:logpb.Force.s)
  return &_impl_.s_;
}
inline const ::logpb::Force_Speed& Force::_internal_s(int index) const {
  return _impl_.s_.Get(index);
}
inline const ::logpb::Force_Speed& Force::s(int index) const {
  // @@protoc_insertion_point(field_get:logpb.Force.s)
  return _internal_s(index);
}
inline ::logpb::Force_Speed* Force::_internal_add_s() {
  return _impl_.s_.Add();
}
inline ::logpb::Force_Speed* Force::add_s() {
  ::logpb::Force_Speed* _add = _internal_add_s();
  // @@protoc_insertion_point(field_add:logpb.Force.s)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force_Speed >&
Force::s() const {
  // @@protoc_insertion_point(field_list:logpb.Force.s)
  return _impl_.s_;
}

// -------------------------------------------------------------------

// Data

// optional .logpb.Message_Types type = 1 [default = Data_Type];
inline bool Data::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Data::has_type() const {
  return _internal_has_type();
}
inline void Data::clear_type() {
  _impl_.type_ = 3;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::logpb::Message_Types Data::_internal_type() const {
  return static_cast< ::logpb::Message_Types >(_impl_.type_);
}
inline ::logpb::Message_Types Data::type() const {
  // @@protoc_insertion_point(field_get:logpb.Data.type)
  return _internal_type();
}
inline void Data::_internal_set_type(::logpb::Message_Types value) {
  assert(::logpb::Message_Types_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void Data::set_type(::logpb::Message_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:logpb.Data.type)
}

// repeated .logpb.Pressure pressure = 2;
inline int Data::_internal_pressure_size() const {
  return _impl_.pressure_.size();
}
inline int Data::pressure_size() const {
  return _internal_pressure_size();
}
inline void Data::clear_pressure() {
  _impl_.pressure_.Clear();
}
inline ::logpb::Pressure* Data::mutable_pressure(int index) {
  // @@protoc_insertion_point(field_mutable:logpb.Data.pressure)
  return _impl_.pressure_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Pressure >*
Data::mutable_pressure() {
  // @@protoc_insertion_point(field_mutable_list:logpb.Data.pressure)
  return &_impl_.pressure_;
}
inline const ::logpb::Pressure& Data::_internal_pressure(int index) const {
  return _impl_.pressure_.Get(index);
}
inline const ::logpb::Pressure& Data::pressure(int index) const {
  // @@protoc_insertion_point(field_get:logpb.Data.pressure)
  return _internal_pressure(index);
}
inline ::logpb::Pressure* Data::_internal_add_pressure() {
  return _impl_.pressure_.Add();
}
inline ::logpb::Pressure* Data::add_pressure() {
  ::logpb::Pressure* _add = _internal_add_pressure();
  // @@protoc_insertion_point(field_add:logpb.Data.pressure)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Pressure >&
Data::pressure() const {
  // @@protoc_insertion_point(field_list:logpb.Data.pressure)
  return _impl_.pressure_;
}

// repeated .logpb.Force force = 3;
inline int Data::_internal_force_size() const {
  return _impl_.force_.size();
}
inline int Data::force_size() const {
  return _internal_force_size();
}
inline void Data::clear_force() {
  _impl_.force_.Clear();
}
inline ::logpb::Force* Data::mutable_force(int index) {
  // @@protoc_insertion_point(field_mutable:logpb.Data.force)
  return _impl_.force_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force >*
Data::mutable_force() {
  // @@protoc_insertion_point(field_mutable_list:logpb.Data.force)
  return &_impl_.force_;
}
inline const ::logpb::Force& Data::_internal_force(int index) const {
  return _impl_.force_.Get(index);
}
inline const ::logpb::Force& Data::force(int index) const {
  // @@protoc_insertion_point(field_get:logpb.Data.force)
  return _internal_force(index);
}
inline ::logpb::Force* Data::_internal_add_force() {
  return _impl_.force_.Add();
}
inline ::logpb::Force* Data::add_force() {
  ::logpb::Force* _add = _internal_add_force();
  // @@protoc_insertion_point(field_add:logpb.Data.force)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logpb::Force >&
Data::force() const {
  // @@protoc_insertion_point(field_list:logpb.Data.force)
  return _impl_.force_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace logpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::logpb::Force_Speed_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logpb::Force_Speed_Type>() {
  return ::logpb::Force_Speed_Type_descriptor();
}
template <> struct is_proto_enum< ::logpb::Message_Types> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logpb::Message_Types>() {
  return ::logpb::Message_Types_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_5fdefs_2eproto
